/*
 * Copyright Â© 2018 Red Hat, Inc
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *       Christian J. Kellner <christian@kellner.me>
 */

#include "config.h"

#include "bolt-enums.h"
#include "bolt-error.h"

#include "bolt-config.h"

#define DAEMON_GROUP "config"
#define CFG_VERSION 1

#define DEFAULT_POLICY_KEY "DefaultPolicy"
#define FORTIFY_MODE_KEY "Fortify"

const char *
bolt_tri_to_string (BoltTri tri)
{
  switch (tri)
    {
    case TRI_ERROR: return "error";

    case TRI_NO:    return "no";

    case TRI_YES:   return "yes";

    default:        return "unknown";
    }
}

GKeyFile *
bolt_config_user_init (void)
{
  GKeyFile *cfg;

  cfg = g_key_file_new ();

  g_key_file_set_comment (cfg, NULL, NULL,
                          " Generated by boltd - do not edit",
                          NULL);

  g_key_file_set_uint64 (cfg, DAEMON_GROUP, "version", CFG_VERSION);

  return cfg;
}

BoltTri
bolt_config_load_default_policy (GKeyFile   *cfg,
                                 BoltPolicy *policy,
                                 GError    **error)
{
  g_autoptr(GError) err = NULL;
  g_autofree char *str = NULL;
  BoltPolicy p;

  if (cfg == NULL)
    return TRI_NO;

  str = g_key_file_get_string (cfg, DAEMON_GROUP, DEFAULT_POLICY_KEY, &err);
  if (str == NULL)
    {
      int res = bolt_err_notfound (err) ? TRI_NO : TRI_ERROR;

      if (res == TRI_ERROR)
        g_propagate_error (error, g_steal_pointer (&err));

      return res;
    }

  p = bolt_policy_from_string (str);
  if (!bolt_policy_validate (p))
    {
      g_set_error (error, BOLT_ERROR, BOLT_ERROR_CFG,
                   "invalid policy: %s", str);
      return TRI_ERROR;
    }

  *policy = p;
  return TRI_YES;
}

void
bolt_config_save_fortify_mode (GKeyFile *cfg,
                               gboolean  value)
{
  g_return_if_fail (cfg != NULL);

  g_key_file_set_boolean (cfg, DAEMON_GROUP, FORTIFY_MODE_KEY, value);
}

int
bolt_config_load_fortify_mode (GKeyFile *cfg,
                               gboolean *fortify,
                               GError  **error)
{
  g_autoptr(GError) err = NULL;
  gboolean p;

  if (cfg == NULL)
    return TRI_NO;

  p = g_key_file_get_boolean (cfg, DAEMON_GROUP, FORTIFY_MODE_KEY, &err);
  if (err == NULL)
    {
      *fortify = p;
      return TRI_YES;
    }

  if (bolt_err_notfound (err))
    return TRI_NO;
  else if (bolt_err_inval (err))
    g_set_error_literal (error, BOLT_ERROR, BOLT_ERROR_CFG, err->message);
  else
    g_propagate_error (error, g_steal_pointer (&err));

  return TRI_ERROR;
}
